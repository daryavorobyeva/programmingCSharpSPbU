# Программирование С# в СПбГУ

## Домашние задания

### Задача №1: [BubbleSort](../main/BubbleSort)

Реализовать сортировку пузырьком
  

<br>

### Задача №2: [StackCalculator](../main/StackCalculator)

Реализовать **Стековый калькулятор** (класс, реализующий выполнение операций `+`, `-`, `*`, `/` над арифметическим выражением в виде строки в постфиксной записи)

<details>
<summary>Условия задачи:</summary>
     
Строка уже дана в обратной польской записи (например, `1 2 3 + *`). Стек реализовать двумя способами (например, массивом или списком) в двух разных классах на основе одного интерфейса.  
Стековый калькулятор должен знать только про интерфейс стека (то есть вообще в коде класса «Стековый калькулятор» не должно быть ни одного упоминания конкретных реализаций стека, даже если очень хочется).  
Числа и арифметические знаки разделены пробелами, числа только целые (но могут быть знаковыми, и уж точно не только из одной цифры, используйте int.Parse или int.TryParse). В результате должно получаться число — результат вычислений. Результат может быть дробным. При попытке деления на 0 должна выдаваться ошибка и программа должна корректно заканчивать работу.
</details>
  


<br>

### Задача №3: [UniqueList](../main/UniqueList)

Реализовать класс **Список** с методами добавления, удаления и изменения элемента по позиции, и, унаследовавшись от него, реализовать класс **UniqueList**, который не содержит повторяющихся значений. Реализовать классы исключений, которые генерируются при попытке добавления в такой список уже существующего или при попытке удаления несуществующего элемента.
  


<br>

### Задача №4: [Routers](../main/Routers)

<details>
<summary>Условия задачи:</summary>
    
Есть участок сети, состоящий из роутеров, связанных Ethernet-соединениями. Поскольку разные куски этой сети администрируют разные организации, у сети отсутствует единая архитектура, что часто приводит к избыточным соединениям между роутерами, либо наоборот, изоляции участков сети. Современные сетевые протоколы устроены так, что избыточные соединения почти столь же опасны, как и их отсутствие — если роутер не знает маршрута до целевого узла, он рассылает пакеты по всем портам, кроме того, откуда пакет пришёл, в надежде, что кто-то из роутеров-адресатов сможет его доставить. Поэтому не исключена ситуация, когда пакеты начинают ходить по кругу до тех пор, пока не исчерпается их время жизни (Time To Live, TTL), что приводит к лавине дублирующихся пакетов, нагружает сеть и снижает общую производительность.

Ваша задача — написать консольное приложение, которое по данной топологии сети генерирует конфигурацию для каждого роутера и проверяет, что все роутеры достижимы. Топология задана в файле в виде списка роутеров и того, к каким другим роутерам они подключены каналами какой пропускной способности, например,
```
1: 2 (10), 3 (5)
2: 3 (1)
```
задаёт сеть из трёх роутеров, где первый связан со вторым и третьим, второй с первым и третьим, третий с первым и вторым. Причём канал между первым и вторым имеет в десять раз большую пропускную способность, чем между вторым и третьим. Вы должны вывести в файл аналогичную таблицу, где оставлены только те соединения, которые необходимы для обеспечения связности сети, без циклов, например,
```
1: 2 (10), 3 (5)
```
Причём конфигурация должна быть в каком-то смысле оптимальной: сумма пропускных способностей всех каналов в сети должна быть максимальной.

Если построить такую таблицу невозможно (то есть сеть изначально была не связной), программа должна вывести в поток ошибок (обратите внимание, не в файл и не совсем на консоль) сообщение, что сеть не связна, и завершить работу с ненулевым кодом возврата. Пути до входного и выходного файлов должны приниматься в качестве параметров.
</details>
      


<br>

### Задача №5: [FunctionalMethods](../main/FunctionalMethods)

Реализовать функции **Map**, **Filter** и **Fold**

<details>
  <summary>Условия задачи:</summary>
    
Map принимает список и функцию, преобразующую элемент списка. Возвращаться должен список, полученный применением переданной функции к каждому элементу переданного списка. Например, `Map(new List<int>() {1, 2, 3}, x => x * 2)` должен возвращать список `[2; 4; 6]`.  
Filter принимает список и функцию, возвращающую булевое значение по элементу списка. Возвращаться должен список, составленный из тех элементов переданного списка, для которых переданная функция вернула true.
Fold принимает список, начальное значение и функцию, которая берёт текущее накопленное значение и текущий элемент списка, и возвращает следующее накопленное значение. Сама Fold возвращает накопленное значение, получившееся после всего прохода списка. Например, `Fold(new List<int>() {1, 2, 3}, 1, (acc, elem) => acc * elem)` работала бы так: сначала в acc клался бы 1, потом умножался бы на 1, потом результат (1) умножался бы на 2, потом результат (2) умножался бы на 3, потом результат (6) возвращался бы в качестве ответа.
</details>
    


<br>

### Задача №6: [Calculator](../main/Calculator)

Написать калькулятор с пользовательским интерфейсом

<details>
Калькулятор должен вычислять операторы немедленно, то есть если пользователь нажимает «7», «+», «3», «+», на экране должно отобразиться «10». Ввод кнопочный, то есть разбор и прямое редактирование выражения делать не надо (соответственно, скобки, приоритет операций и т.п. калькулятор не должен поддерживать). Рекомендуется вспомнить про конечные автоматы для упрощения формализации вещей в духе «если оператор нажат первый раз, ждём второй операнд, если второй операнд уже есть, печатаем ответ и запоминаем оператор».
</details>
  


<br>

## Лицензия

Распространяется по лицензии MIT. `LICENSE.txt` — для получения дополнительной информации.
